# 基础篇

__站在设计者的角度看问题,把自己的程序看成黑盒子,输入什么,输出什么,中间过程暂时不考虑.__

__代码的美学标准__:

- 当程序设计中发生某些改变时，其造成的影响越小，说明代码质量越高.
- **more code = more bug**.
- 时空复杂度

## 数学运算

取余运算可以循环的利用某些资源.

### 位运算

- &与运算 
  - 模2运算改成按位与1运算效率更高.
  - 一个数和其相反数按位与得到其二进制表示的最后一个1.
- |或运算
- ^ 异或运算
  - 和自己互为逆运算,即若a ^ b=c,则a ^ c=b,b ^ c=a,可利用此实现两数的交换(a !=b).
  - 实际上异或运算在统计相应位上1的奇偶性,可借此理解其与自己互为逆运算.
- ~非运算
  - 可实现循环读入：`while(~scanf())`.

### 左移和右移

- <<左移
- \>>右移,相当于除以2向下取整(除法向0取整).

### `inttypes`头文件

- `int8_t`
- `int16_t`
- `int32_t`
- `int64_t`

对应的格式占位符:`PRIdx`(x为字节数),实际上为字符串,底层为宏,可根据系统环境自动获取合适的格式占位符.

### 左值和右值

如果代码到了下一行这个值还可以访问到,那么该值为左值,否则为右值.

## 程序流程控制方法

非零即为真,`false:0,NULL,'\0'`.

!!(x):逻辑归一化,真->1,假->0.

### CPU分支预测的利用

`#define likely(x)   __builtin_expect(!!(x),1)`   likely代表x经常成立.

`#define unlikely(x)   __builtin_expect(!!(x),0)`   unlikely代表x不经常成立.

以上两条语句为操作系统内核上定义的宏.

eg:`if(__builtin_expect(!!(x < 0),0)) return false;`的功能和`if(x < 0) return false;`等价,但效率更高.前者相当于告诉CPU,x<0大概率不会发生,让CPU提前预取x<0未发生时应该执行的指令,从而利用流水线的并行执行来提高效率.

__综上,在不影响代码可读性的前提下,应尽可能减少分支结构的使用.__

其他`__builtin_`相关宏：

- `__builtin_ffs(x)`:返回x中最后一个为1的位是从后向前的第几位
- `__builtin_popcount(x)`:x中1的个数
- `__builtin_ctz(x)`:x末尾0的个数，x = 0时结果未定义
- `__builtin_clz(x)`:x前导0的个数，x = 0时结果未定义
- `__builtin_prefetch(const void *addr, ...)`:对数据手动预取的方法
- `__builtin_types_compatible_p(type1, type2)`:判断`type1`和`type2`是否是相同的数据类型
- `__builtin_expect(long exp, long c)`:用来引导`gcc`进行条件分支预测
- `__builtin_constant_p(exp)`:判断`exp`是否在编译时就可以确定其为常量
- `__builtin_parity(x)`:x中1的奇偶性
- `__builtin_return_address(n)`:当前函数的第n级调用者的地址

### FOR语句

1. 初始化

2. 循环条件判断
3. 执行代码块
4. 执行后操作
5. 跳转到2执行

### goto语句

- 跳过代码段

- 不影响变量的存在性

- ```c
  用goto语句实现if，else
  int main() {
      int n;
      scanf("%d", &n);
      n % 2 == 0 && ({ goto if_stmt; 1; }); 
      // ()将{}里面的内容转换为表达式，该表达式的值为{}里最后一条语句的值
      !(n % 2 == 0) && ({goto else_stmt; 1; });
  if_stmt:
      printf("%d is even\n", n);
      goto if_end;
  else_stmt:
      printf("%d is odd\n", n);
      goto if_end;
  if_end:
      return 0;
  }
  ```

### 一条语句

- 复合语句
- 表达式语句
- 选择(分支)语句
- 循环语句
- 跳转语句

## 代码优化技巧

### 位运算

- &代替%2.
- ^实现两数交换.
- ~实现循环读入.
- &15或者^48将数字字符转换成数字.

### 代码结构

- 不影响代码可读性的前提下减少分支结构的使用.

### 逻辑运算

- &&,||的短路.
- 逻辑表达式的返回值.

### 宏

- 宏代替函数.

作为条件判断时,a != b等价于a - b.

## 函数

函数程序的可读性优于普通程序,且易于debug.

形参的所有修改,都不会改变实参.

### 递归程序

程序调用自身的__编程技巧__叫做递归.

思想类似于数学归纳法.

递归程序的组成部分:

- 语义信息处理
- 边界条件处理
- 针对于问题的__处理过程__和__递归过程__.
- 结果返回

主函数也是函数，也可以递归调用.

### 欧几里得算法(辗转相除法)

#### 作用:

- 计算两个数字的最大公约数.
- 快速求解a*x + b*y = 1方程的一组整数解.

#### 原理:

`gcd(a, b) = gcd(b, a % b)`,当b = 0时,a即为a, b的最大公约数.

证明:

假设`gcd(a, b) = r`

1. 证明b, a % b的公约数中包含r

设`a = xr, b= yr`, (x, y 属于整数) => x, y互素,即`gcd(x, y) = 1`(否则r不是最大),则`a % b = a - kb = xr - kyr = r(x - ky)`,k属于整数且k = a / b.

2. 证明r为b, a % b的最大公约数

`b = yr, a % b = r(x - ky)`,只需证`y, x - ky`互素,即`gcd(y, x - ky) = 1`,设`gcd(y, x - ky) = d`,只需证d恒等于1.

`y = md, x - ky = nd,(m, n属于整数) =>y = md,x = nd + ky = nd + kmd = d(n + km)`,又`gcd(x, y) = 1`,故d恒等于1.

综上,`gcd(a, b) = gcd(b, a % b).`

__最小公倍数__`lcm = a * b / gcd(a, b)`.

证明:

`a = gcd(a, b)  * x, b = gcd(a, b) * y, a * b是a, b的公倍数,a * b = x * y * gcd(a, b) * gcd(a, b),故lcm = a * b / gcd(a, b)`.

#### 扩展欧几里得算法

__求解`ax + by = gcd(a, b) = c`(贝祖等式)的整数值解.__

ax + by = 1的一组整数值解(a, b, x, y均为整数).

1. 该方程要有整数值解,则a, b互素,即`gcd(a, b) = 1`,证明:

设`gcd(a, b) = c, a = mc, b = nc, m, n均为正整数,则mcx + ncy = 1 = c(mx + ny) =>c = 1.`

2. b = 0时,ax = 1, y为任意值,而欧几里得算法的最后一层,b = 0,设a = 1,则找到一组整数解`x2 = 1, y2`为任意值(默认为0),利用数学归纳法,设第k层(b, a % b)得到一组整数解`x1, y1`,可以得到第k+1层(a, b)的一组整数值解`x = y1,y = x1 -ky1`.

实际上,求解该方程的过程就是通过欧几里得算法一步一步向下递推减小问题规模,到最后一层得到一组符合条件的解,然后一步一步向上回溯得到问题的解.

### 变参函数

__VA家族__

- `va_list`类型的变量获得指定变量往后的参数列表.
- `va_start(va_list arg, 类型)`函数定位`arg`后面第一个参数位置.
- `va_arg(va_list arg, 类型)`函数获取可变参数列表中的下一个参数.
- `va_end`函数结束整个获取可变参数列表的动作.

实际上,上面三个"函数"其实是宏.

`printf()`函数底层是由`putchar()`函数实现的,c++中的`cout`底层是由`printf()`实现的.

### 内联函数

- 用`inline`关键字将函数变为内联函数，调用时直接替换为函数体，类似宏，可避免频繁调用函数造成系统栈的大量占用
- `inline`需与函数定义放在一起
- 内联是以代码膨胀为代价的，仅仅省去了函数调用的开销，故若函数体的代码较长，不宜使用内联函数

## 数组

### 关键点总结

- 数组向操作系统申请内存空间是在编译阶段完成的.

- 可变长数组:`eg:int a[2 * n]`.

- []不是c语言的语法,而是一种运算符,a[b]等价于*(a + b).

- 一维数组可以表示两方面信息(甚至三方面).

### 数组与函数的关系

__函数是压缩的数组,数组是展开的函数.__

- 所有传入函数的地方都可以用数组代替,所有传入数组参数的位置都可以用函数去进行思维模型的抽象.

- 面对一个算法流程时,如果这个算法流程一开始是通过数组解决问题,说明这个算法流程的数组环节可以改成思维方式更加抽象化的函数去进行更高级的应用.

### 素数筛算法

__学习一个算法时将其当成算法框架学习.__

此算法可扩展为求一个范围内每个数字的最大/小素因子.

1既不是素数也不是合数.

- 标记一个范围内的数字是否是合数,没有被标记的则为素数.
- 空间复杂度为O(n),时间复杂度为O(n * `loglogn`)(接近于O(N),但有些合数不止被标记一次,所以达不到O(n)).
- 总体思想是用素数去标记掉不是素数的数字.

1. 用prime[i]来标记i是否是合数.

2. 标记为1的数字为合数,否则为素数.

3. 第一次知道2是素数,则将2的倍数标记为1.

4. 向后找到第一个没有被标记的数字i.

5. 将i的倍数全部标记为合数.

6. 重复4-6步,直到标记完范围内所有的数字.

   ```c
   int prime[MAX_N + 5] = {0};
   void init() {
       for (int i = 2; i <= MAX_N; i++) {
           if (prime[i]) continue;
           prime[++prime[0]] = i; //利用prime[0]计数,从prime[1]开始从小到大存储素数
           for (int j = i; j <= MAX_N / i; j++) { //减少重复标记,防止数据超出表示范围
               prime[j * i] = 1;
           }
       }
       return ;
   }
   ```

### 线性筛算法

20万以内的素数,第n个素数大约在20 n以内.

任何正整数都可以表示成素因子幂次连乘的形式,即N = P<sub>1</sub><sup>a<sub>1</sub></sup> * P<sub>2</sub><sup>a<sub>2</sub></sup> * ......(P<sub>1</sub>,P<sub>2</sub>......均为素数).

- 标记一个范围内的数字是否是合数,没有被标记的则为素数.
- 空间复杂度为O(n),时间复杂度为O(n).
- 总体思想是用一个整数M去标记合数N,其中N和M具有如下性质:
  - N的因子中最小的素数为P.	
  - N = P * M.=>M是N除N以外的最大因子.
  - P一定小于等于M中最小的素因子(保证M最大).
  - 利用M * P<sup>'</sup>(所有不大于M中最小素数的集合)标记N<sub>1</sub>,N<sub>2</sub>,N<sub>3</sub>......(不鸣则已，一鸣惊人).


```c
int prime[MAX_N + 5] = {0};
void init() {
    for (int i = 2; i <= MAX_N; i++) { //i相当于M
        if (!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0]; j++) {
            if (prime[j] * i > MAX_N) break; //prime[j]相当于P
            prime[prime[j] * i] = 1;
            if (i % prime[j] == 0) break; //保证M最大
        }
    }
    return ;
}
```

扩展:罗宾米勒测试,判断一个数是否是素数的时间复杂度为O(1),标记一个范围内的素数的时间复杂度为O(log n),但是有很小的误差.

定义F(n)表示n的因子个数,若a, b互素,则有F(a * b) = F(a) * F(b).(由正整数写成素因子幂次连乘形式可得)且由排列组合可得F(N) = (a<sub>1</sub> + 1) * (a<sub>2</sub> + 1) * ......

利用线性筛算法框架实现求一个范围内每个数字的因子个数:

```c
int prime[MAX_N + 5] = {0};
int f[MAX_N + 5] = {0}; //记录因子个数
int cnt[MAX_N + 5] = {0}; //记录最小素因子的幂次

void init() {
    for (int i = 2; i <= MAX_N; i++) {
        if (!prime[i]) {
            prime[++prime[0]] = i;
            f[i] = 2;
            cnt[i] = 1;
        }
        for (int j = 1; j <= prime[0]; j++) {
            if (prime[j] * i > MAX_N) break;
            prime[prime[j] * i] = 1;
            if (i % prime[j] == 0) {
                f[i * prime[j]] = f[i] / (cnt[i] + 1) * (cnt[i] + 2);
                cnt[i * prime[j]] = cnt[i] + 1;
                break;
            }else {
                f[prime[j] * i] = f[i] * f[prime[j]];
                cnt[i * prime[j]] = 1;
            }    
        }
    }
    return ;
}
```

### 二分查找与牛顿迭代

#### 二分查找

两种特殊情况:

找第一个符合条件的值:

- 注意舍去的一半是否都不符合条件.
- 虚拟尾解决都不符合的特殊情况.
- ```c
  //000000111111 找第一个1(可抽象成找第一个符合条件的值)
  int binary_search3(int *arr, int n) {
      int head = 0, tail = n, mid;//tail指向虚拟尾
      while (head < tail) {
          mid = (head + tail) >> 1;
          if (arr[mid] == 0) head = mid + 1;
          else tail = mid;//注意不是mid - 1
      }
      return head == n ? -1 :head;
  }
  ```

找最后一个符合条件的值:

- 注意舍去的一半是否都不符合条件.
- 上取整解决下取整造成的bug.
- 虚拟头解决都不符合的特殊情况.
- ```c
  //111111000000 找最后一个1(可抽象成最后一个符合条件的值)
  int binary_search4(int *arr,int n) {
      int head = -1, tail = n - 1, mid; //head指向虚拟头
      while (head < tail) {
          mid = (head + tail + 1) >> 1;
          if (arr[mid] == 0) tail = mid - 1;
          else head = mid; //注意不是mid + 1
      }
      return head;
  }
  ```

#### 牛顿迭代

思想:利用切线递推逼近,得到递推式x<sub>2</sub> = x<sub>1</sub> - f(x<sub>1</sub>) /f<sup>'</sup>(x<sub>1</sub>).

利用牛顿迭代实现平方根函数:

```c
double func(double x, double n) {
    return x * x - n;
}

double f(double x) {
    return 2 * x;
}

double NewTon(double (*F)(double, double), double (*f)(double), double n) {
    double x =1.0;
    #define EPSL 1e-7
    while (fabs(F(x, n)) > EPSL) {
        x -= F(x, n) / f(x);
    }
    #undef EPSL
    return x;
}
```

时间复杂度和二分一样为O(log n),但二分的底数为2,而牛顿迭代的底数是动态的,迭代多次以后会远大于2.实际上还有方法可以实现O(1)级别的平方根函数,三步就可以得到结果,其本质还是牛顿迭代(游戏雷神之锤3的工程师).

## 预处理命令

C源码 `==预处理(预编译)(gcc -E)==>` 待编译源码 `==编译(gcc -S)==>汇编(gcc -c)==>` 对象文件 `==链接==>` 可执行程序

- 编译：检查是否有语法错误
  - 语法格式
  - 未声明标识符
- 链接：检查是否有定义缺失或冲突

`extern`声明变量.

一个C语言源码对应一个对象文件,链接阶段将所有对象文件链接在一起.

### 宏定义

__符号替换,不做运算,只占一行__.

#字符串化，##连接运算符.

- 定义符号常量

  - `#define PI 3.1415926`

- 定义傻瓜表达式

  - `#define S(a, b) a * b` 

- 定义代码段

  ```c
  #define P(a) { \
  	printf("%d\n", a); \
  } //在C和C++中,宏不允许定义在多行,故需\连接符把多行代码连接成一行
  ```

运行效率宏优于函数,存储空间函数优于宏.

### 预定义的宏

- `__DATE__`:替换为上一次编译时的日期
- `__TIME__`:替换为上一次编译时的时间
- `__LINE__`:替换为该宏所在的行号
- `__FILE__`:替换为该宏所在的文件名
- `__func__`:替换为函数名,非标准(与环境有关)
- `__FUNC__`:同`__func__`
- `__PRETTY_FUNCTION__`:更详细的函数信息,非标准

### 条件式编译

可用于代码剪裁，实际上是让编译器替我们写代码.

- `#ifdef DEBUG`:是否定义了DEBUG宏
- `#ifndef DEBUG`:是否没定义DEBUG宏
- `#if MAX_N == 5`:宏MAX_N是否等于5
- `#elif MAX_N == 4`:否则宏MAX_N是否等于4
- `#else`
- `#endif`:使用条件式编译时,末尾一定要以`#endif`结尾

`__attribute__((constructor))`:宏, 在函数定义前用`__attribute__`设置函数属性,属性`constructor`(构造)使函数先于主函数执行.

泛型宏_Generic:可以将a替换为相应的字符串.

```c
#define TYPE(a) _Generic((a),\
    int  : "%d",\
    double : "%.2lf",\
    char * : "%s"\
)
```

## 字符串

相关函数(头文件:string.h):

- `strlen(str)`:计算字符串长度,以\0作为结束符(不包括\0)
- `strcmp(str1, str2)`:字符串比较
- `strcpy(dest, src)`:字符串拷贝
- `strncmp(str1, str2, n)`:安全的字符串比较(先比较n)
- `strncpy(str1, str2, n)`:安全的字符串拷贝
- `memcpy(str1, str2, n)`:内存拷贝(将`str2`的n个字节数拷贝到`str1`,不能处理内存重叠的情况)
- `memmove(str1, str1, n)`:同`memcpy()`,能处理内存重叠的情况
- `memcmp(str1, str2, n)`:内存比较(内存操作快于字符串操作)
- `memset(str1, c, n)`:内存设置(将`str1`的n个字节(内存操作均以字节为单位)设置为c)

相关函数(头文件`stdio.h`):(可解决字符串拼接问题)

- `sscanf(str1, format, ...)`:从字符串`str1`读入内容,`eg:sscanf(str, "%d%[ ^ $]s", &a, str);//从str中读入一个int类型变量到a中,剩余的内容读入到str中`
- `sprintf(str1, format, ...)`:将内容输出到`str1`中
- __以上两个函数的本质作用__:前者将字符串类型数据转换为任意类型数据,后者将任意类型数据转换为字符串类型数据.

格式控制字符串%g可以去除浮点数多余的0，正则表达式[]可控制字符串格式.

当要读入可见字符时,均可使用%s占位符,将其读入到字符数组中,而不必因为读入一个字符去使用%c(容易因为输入流问题导致错误).

## 结构体、联合体与枚举类型

### 结构体

```c
struct person {
    char name[20];
    int age;
    char gender;
    float height;
};
```

`struct person`才是结构体类型(C语言特有).

如果没有`person`则为匿名结构体,匿名结构体只能使用一次.

所占内存为结构体内基础字段类型中最大者的整数倍. =>将相同类型的变量放在一起定义可节省内存空间.

宏`Pragma pack`可强行更改结构体对齐规则,其参数只能是'1', '2', '4', '8', '16'.

访问内部字段的两种方式:

- 直接引用
  - .
  - 通过原变量
- 间接引用
  - ->
  - 通过原变量的地址

对齐补齐规则：

- 类型都有一个对齐值，内建类型的对齐值等于其自身大小
- 结构体的对齐值，等于其成员中的最大对齐值
- 成员被存储在其整数倍的对齐位置上
- 可以通过#`pragma pack`限制对齐值的最大值

### 联合体

```c
union register {
    struct {
        unsign char byte1;
        unsign char byte2;
        unsign char byte3;
        unsign char byte4;
    }bytes;
    unsigned int number;
}
```

所占内存为基础字段类型中的最大者.

### 枚举类型

```c
eg:
enum Number {
	zero,
	one,
	two,
	three,
	four,
	MAX_Number
} ;
```

- 第一项默认为0，之后每项依次+1
- 可实现数组自动扩容(通过MAX_Number得到数组大小)
- 增加代码可读性
- 辅助进行程序设计

### 位域

```c
eg:
struct A {
    unsigned int a:1; //a为1位二进制
    unsigned int b:2; //b为2位二进制
    unsigned int c:3; //c为3位二进制
} ; // sizeof(struct A) = 4(根据类型的大小分配内存)
```

## 指针与地址

### 指针变量也是变量

变量用于存值且有大小有地址,指针变量的大小为4字节(32位操作系统)/8字节(64位操作系统).

指针变量可以参与运算,但只能参与加减法(+1相当于+该指针指向类型的大小).

### 等价形式转换

`int *p = &a;`

- `*p <=> a(原始变量)`
- `p + 1 <=> &p[1]`
- `p[n] <=> *(p + n)`
- `p->filed <=> (*p).filed <=> a.filed`

### typedef的用法

可以将变量名变为类型别名,和宏定义的区别是宏只是简单的字符替换,而typedef是定义了新的类型名.

- 内建类型的重命名

  - `typedef char * pchar;`

- 结构体类型的重命名

  - ```C
    typedef struct _node {
        int x, y;
    }Node, *PNode;
    ```

- 函数指针命名

  - 类型:`typedef int (*func)(int);`
  - 变量:`int (*func)(int);`

### 分辨指针的真实身份

去掉指针后剩下的就是指针指向的类型.

- 变量或函数名前面加个*，就变成了指向变量或函数的指针
- 变量名后面加个[]，就变成了相关类型的数组

从后往前读，翻译如下：

- p就读“p是一个”
- *就读“指针，指向”或“指针数组，指向”
- `const`就读“常量”
- 类型正常读

### main函数参数

- `int main();`
- `int main(int argc, char *argv[]);argc`表示当前程序从外部接收到的命令行参数个数(以空格为分隔符),`argv[]`表示命令行参数的内容.
- `int main(int argc, char *argv[], char **env);env`表示环境变量.
- `return 0`:是操作系统调用的主函数,故返回值返回给操作系统,而对于操作系统来说,0为真值,1为假值.程序运行之后,可通过`echo $?`命令查看main函数的返回值.

### `qsort`函数

- 头文件：`stdlib.h`
- 原型：`void qsort(void *arr, size_t conut, size_t size, int (* comp)(const void *, const void *));`
- arr:待排序数组的起始位置
- `count`:排序元素数量
- `size`:每个元素的所占字节数
- `comp`:比较规则函数

## 文件操作

### 文件打开模式

`FILE *fp = fopen("filename", "w");`

| 文件访问模式 |   含义   |           解释           | 文件存在的操作 | 文件不存在的操作 |
| :----------: | :------: | :----------------------: | :------------: | :--------------: |
|     "r"      |    读    |     以读方式打开文件     |   从头开始读   |     打开失败     |
|     "w"      |    写    |     以写方式创建文件     |    清空内容    |    创建新文件    |
|     "a"      |   追加   |     向文件中追加内容     |   写入到末尾   |    创建新文件    |
|     "r+"     |  读扩展  | 以读写的方式打开一个文件 |   从头开始读   |       出错       |
|     "w+"     |  写扩展  | 以读写的方式创建一个文件 |    清空内容    |    创建新文件    |
|     "a+"     | 追加扩展 | 以读写的方式打开一个文件 |   写入到末尾   |    创建新文件    |

### 操作文件读写位置

`ftell(fp)`:返回文件位置指针的值

`fseek(fp, dis, pos_center)`设置文件位置指针：

- SEEK_SET:以文件开头位置为中心
- SEEK_CUR:以文件当前位置为中心
- SEEK_END:以文件结尾位置为中心

通过`feek()`和r+，w+可实现想从哪读就从哪读，想从哪写就从哪写。但a+模式下，无论怎么设置文件位置指针，都是向文件末尾写入，读入则想从哪读就从哪读。

### 二进制文件操作

二进制文件(后缀名`dat`)打开模式为常规文件打开模式后多个b。

二进制文件操作相对于常规文件操作的优势：读写效率高。

`fwrite()`函数：

- 功能：向文件中写入二进制数据
- 原型：`fwrite(const void *buffer, size_t size, size_t count, FILE *fp)`
- `buffer`:数据区的首地址
- `size`:每个数据的大小
- `count`:写入数据的个数
- `fp`:文件指针

`fread()`函数：

- 功能：从文件中读入二进制数据
- 其他同`fwrite()`
- 返回值为成功读入的字节数

## 工程项目开发

### OJ VS 工程

|  OJ  |           实现算法           |  优化时空复杂度  |                        |          | 单文件 |
| :--: | :--------------------------: | :--------------: | :--------------------: | :------: | :----: |
| 工程 | 实现功能(稳定、正常、无漏洞) | 易读(命名、注释) | 易维护(易修改、易扩展) | 性能优化 | 多文件 |

__命名规范__

- 驼峰命名法,下划线命名法(不要同时用)
- 动词,名词
- 前缀后缀

__代码风格__

- 空格,空行,长语句
- 缩进,括号
- 注释

__函数__

- 声明,参数,返回值
- 高内聚,低耦合

......

### 头文件(.h)与源文件

头文件中放声明,源文件中放定义.

`<head.h>`:编译器将在系统路径下查找.

`"head.h"`:编译器将在当前路径下查找.

### 文件放置规范

- 所有头文件放在include目录下
- 所有源文件放在src目录下

### `makefile`工具

- 方便多文件链接编译

### 链接库

#### 静态链接库(大)

- 生成库
  - `gcc -o 目标文件 -c 源文件`
  - `ar rcs 库文件.a 目标文件`
- 使用库
  - `gcc 源文件 -L路径 -l库名`

#### 动态链接库(小)

- 生成库
  - `gcc -o 目标文件 -c 源文件`
  - `gcc -shard -o 库文件.so 目标文件`
- 使用库
  - `gcc 源文件 -L路径 -l库名`
- 设置环境变量
  - `export LD_LIBRARY_PATH=路径:$LD_LIBRARY_PATH`

### gdb

编译:`gcc -g 源文件`

调试:`gdb 程序`

命令:

- l	显示源码
- b   设置断点
- info b    查看断点情况
- r    运行程序
- p    输出变量
- watch    观察变量
- n    下一步
- c    继续程序
- q    退出gdb

